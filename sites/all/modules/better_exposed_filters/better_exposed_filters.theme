<?php
/**
<<<<<<< HEAD
 * Themes a select element as a collection of checkboxes enclosed in a collapsible fieldset
 *
 * @param array $vars - An array of arrays, the 'element' item holds the properties of the element.
 *                      Properties used: title, value, options, description
 * @return HTML string representing the form element.
 */
function theme_select_as_checkboxes_fieldset($vars) {
  // Merge incoming element with some default values. Prevents a lot of
  //    $foo = isset($bar) ? $bar : $bar_default;
=======
 * @file
 * Provides theming functions to display exposed forms using different
 * interfaces.
 */

/**
 * Themes a select element as checkboxes enclosed in a collapsible fieldset.
 *
 * @param array $vars
 *   An array of arrays, the 'element' item holds the properties of the element
 *
 * @return string
 *   HTML representing the form element.
 */
function theme_select_as_checkboxes_fieldset($vars) {
  // Merge incoming element with some default values. Prevents a lot of this.
  // $foo = isset($bar) ? $bar : $bar_default;
>>>>>>> SiteReformation
  $element = array_merge(
    array(
      '#bef_title' => '',
      '#bef_description' => '',
      '#bef_operator' => array(),
    ),
    $vars['element']
  );

  $fieldset = array(
    '#title' => $element['#bef_title'],
    '#description' => $element['#bef_description'],
    '#attributes' => array(
      'class' => array(
        'bef-select-as-checkboxes-fieldset',
        'collapsible',
      ),
    ),
  );
  if (empty($element['#value'])) {
    // Using the FAPI #collapsible and #collapsed attribute doesn't work here
    // TODO: not sure why...
    $fieldset['#attributes']['class'][] = 'collapsed';
  }

  // We rendered the description as part of the fieldset element, don't render
<<<<<<< HEAD
  // it again along with the checkboxes
=======
  // it again along with the checkboxes.
>>>>>>> SiteReformation
  unset($element['#bef_description']);

  $children = '';
  if (!empty($element['#bef_operator'])) {
<<<<<<< HEAD
    // Put an exposed operator inside the fieldset
    $children = drupal_render($element['#bef_operator']);
  }

  // Render the checkboxes
=======
    // Put an exposed operator inside the fieldset.
    $children = drupal_render($element['#bef_operator']);
  }

  // Render the checkboxes.
>>>>>>> SiteReformation
  $children .= theme('select_as_checkboxes', array('element' => $element));

  $fieldset['#children'] = $children;
  return theme('fieldset', array('element' => $fieldset));
}

/**
<<<<<<< HEAD
 * Themes a select element as a set of checkboxes
 *
 * @see theme_select(), http://api.drupal.org/api/function/theme_select/6
 * @param array $vars - An array of arrays, the 'element' item holds the properties of the element.
 *                      Properties used: title, value, options, description
 * @return HTML string representing the form element.
=======
 * Themes a select element as a set of checkboxes.
 *
 * @see http://api.drupal.org/api/function/theme_select/7
 *
 * @param array $vars
 *   An array of arrays, the 'element' item holds the properties of the element.
 *
 * @return string
 *   HTML representing the form element.
>>>>>>> SiteReformation
 */
function theme_select_as_checkboxes($vars) {
  $element = $vars['element'];
  if (!empty($element['#bef_nested'])) {
    if (empty($element['#attributes']['class'])) {
      $element['#attributes']['class'] = array();
    }
    $element['#attributes']['class'][] = 'form-checkboxes';
    return theme('select_as_tree', array('element' => $element));
  }

<<<<<<< HEAD
  // the selected keys from #options
  $selected_options = empty($element['#value']) ? $element['#default_value'] : $element['#value'];

  // Grab exposed filter description.  We'll put it under the label where it makes more sense.
  $description = '';
  if (!empty($element['#bef_description'])) {
    $description = '<div class="description">'. $element['#bef_description'] .'</div>';
=======
  // The selected keys from #options.
  $selected_options = empty($element['#value']) ? $element['#default_value'] : $element['#value'];
  if (!is_array($selected_options)) {
    $selected_options = array($selected_options);
  }

  // Grab exposed filter description.  We'll put it under the label where it
  // makes more sense.
  $description = '';
  if (!empty($element['#bef_description'])) {
    $description = '<div class="description">' . $element['#bef_description'] . '</div>';
>>>>>>> SiteReformation
  }

  $output = '<div class="bef-checkboxes">';
  foreach ($element['#options'] as $option => $elem) {
    if ('All' === $option) {
<<<<<<< HEAD
      // TODO: 'All' text is customizable in Views
      // No need for an 'All' option -- either unchecking or checking all the checkboxes is equivalent
      continue;
    }

    // Check for Taxonomy-based filters
=======
      // TODO: 'All' text is customizable in Views.
      // No need for an 'All' option -- either unchecking or checking all the
      // checkboxes is equivalent.
      continue;
    }

    // Check for Taxonomy-based filters.
>>>>>>> SiteReformation
    if (is_object($elem)) {
      $slice = array_slice($elem->option, 0, 1, TRUE);
      list($option, $elem) = each($slice);
    }

<<<<<<< HEAD
    /*
     * Check for optgroups.  Put subelements in the $element_set array and add a group heading.
     * Otherwise, just add the element to the set
     */
=======
    // Check for optgroups.  Put subelements in the $element_set array and add
    // a group heading. Otherwise, just add the element to the set.
>>>>>>> SiteReformation
    $element_set = array();
    $is_optgroup = FALSE;
    if (is_array($elem)) {
      $output .= '<div class="bef-group">';
      $output .= '<div class="bef-group-heading">' . $option . '</div>';
      $output .= '<div class="bef-group-items">';
      $element_set = $elem;
      $is_optgroup = TRUE;
    }
    else {
      $element_set[$option] = $elem;
    }

    foreach ($element_set as $key => $value) {
      $output .= bef_checkbox($element, $key, $value, array_search($key, $selected_options) !== FALSE);
    }

    if ($is_optgroup) {
<<<<<<< HEAD
      $output .= '</div></div>';    // Close group and item <div>s
=======
      // Close group and item <div>s.
      $output .= '</div></div>';
>>>>>>> SiteReformation
    }

  }
  $output .= '</div>';

<<<<<<< HEAD
  // Fake theme_checkboxes() which we can't call because it calls theme_form_element() for each option
=======
  // Fake theme_checkboxes() which we can't call because it calls
  // theme_form_element() for each option.
>>>>>>> SiteReformation
  $attributes['class'] = array('form-checkboxes', 'bef-select-as-checkboxes');
  if (!empty($element['#bef_select_all_none'])) {
    $attributes['class'][] = 'bef-select-all-none';
  }
<<<<<<< HEAD
=======
  if (!empty($element['#bef_select_all_none_nested'])) {
    $attributes['class'][] = 'bef-select-all-none-nested';
  }
>>>>>>> SiteReformation
  if (!empty($element['#attributes']['class'])) {
    $attributes['class'] = array_merge($element['#attributes']['class'], $attributes['class']);
  }

  return '<div' . drupal_attributes($attributes) . ">$description$output</div>";
}

/**
<<<<<<< HEAD
 * Themes a select element as a series of hidden fields
 *
 * @see theme_select(), http://api.drupal.org/api/function/theme_select/6
 * @param array $vars - An array of arrays, the 'element' item holds the properties of the element.
 *                      Properties used: title, value, options, description
 * @return HTML string representing the form element.
=======
 * Themes a select element as a series of hidden fields.
 *
 * @see http://api.drupal.org/api/function/theme_select/7
 *
 * @param array $vars
 *   An array of arrays, the 'element' item holds the properties of the element.
 *
 * @return string
 *   HTML representing the form element.
>>>>>>> SiteReformation
 */
function theme_select_as_hidden($vars) {
  $element = $vars['element'];
  $output = '';
  $selected_options = empty($element['#value']) ? $element['#default_value'] : $element['#value'];
  $properties = array(
    'title' => isset($element['#title']) ? $element['#title'] : '',
    'description' => isset($element['#bef_description']) ? $element['#bef_description'] : '',
    'required' => FALSE,
  );

  foreach ($element['#options'] as $option => $elem) {
<<<<<<< HEAD
    // Check for Taxonomy-based filters
=======
    // Check for Taxonomy-based filters.
>>>>>>> SiteReformation
    if (is_object($elem)) {
      $slice = array_slice($elem->option, 0, 1, TRUE);
      list($option, $elem) = each($slice);
    }

<<<<<<< HEAD
    /*
     * Check for optgroups.  Put subelements in the $element_set array and add a group heading.
     * Otherwise, just add the element to the set
     */
=======
    // Check for optgroups.  Put subelements in the $element_set array and add a
    // group heading. Otherwise, just add the element to the set.
>>>>>>> SiteReformation
    $element_set = array();
    if (is_array($elem)) {
      $element_set = $elem;
    }
    else {
      $element_set[$option] = $elem;
    }

    foreach ($element_set as $key => $value) {
<<<<<<< HEAD
      // Only render fields for selected values -- no selected values renders zero fields
      if (array_search($key, $selected_options) !== FALSE) {
        // Custom ID for each hidden field based on the <select>'s original ID
        $id = drupal_html_id($element['#id'] . '-' . $key);

        // Very similar to theme_hidden (http://api.drupal.org/api/function/theme_hidden/6)
        $hidden = '<input type="hidden" '
          . 'name="'. filter_xss($element['#name']) .'[]" '    // brackets are key -- just like select
          . 'id="'. $id .'" '
          . 'value="'. check_plain($key) .'" '
          . drupal_attributes($element['#attributes']) .' />';
        $output .= theme('form_element', array('element' => array_merge($properties, array('#id' => $id, '#children' => $hidden))));
=======
      // Only render fields for selected values -- no selected values renders
      // zero fields.
      if (array_search($key, $selected_options) !== FALSE) {
        $hidden = array(
          // Custom ID for each hidden field based on the <select> element's
          // original ID.
          'id' => drupal_html_id($element['#id'] . '-' . $key),
          'name' => check_plain($element['#name']) . '[]',
          'value' => check_plain($key),
        );
        $output .= theme('form_element', array(
          'element' => array_merge($properties, array(
            '#id' => $id,
            '#children' => theme_hidden(array('element' => $hidden)),
          ))
        ));
>>>>>>> SiteReformation
      }
    }
  }
  return $output;
}

/**
<<<<<<< HEAD
 * Themes a select element as a collection of radio buttons enclosed in a collapsible fieldset
 *
 * @param array $vars - An array of arrays, the 'element' item holds the properties of the element.
 *                      Properties used: title, value, options, description
 * @return HTML string representing the form element.
 */
function theme_select_as_radios_fieldset($vars) {
  // Merge incoming element with some default values. Prevents a lot of
  //    $foo = isset($bar) ? $bar : $bar_default;
=======
 * Themes a select element as radio buttons enclosed in a collapsible fieldset.
 *
 * @param array $vars
 *   An array of arrays, the 'element' item holds the properties of the element.
 *
 * @return string
 *   HTML representing the form element.
 */
function theme_select_as_radios_fieldset($vars) {
  // Merge incoming element with some default values. Prevents a lot of this.
  // $foo = isset($bar) ? $bar : $bar_default;
>>>>>>> SiteReformation
  $element = array_merge(
    array(
      '#bef_title' => '',
      '#bef_description' => '',
      '#bef_operator' => array(),
    ),
    $vars['element']
  );

<<<<<<< HEAD
  // The "all" option is the first in the list. If the selected radio button is the all
  // option, then leave the fieldset collapsed.  Otherwise, render it opened.
=======
  // The "all" option is the first in the list. If the selected radio button is
  // the all option, then leave the fieldset collapsed.  Otherwise, render it
  // opened.
>>>>>>> SiteReformation
  $keys = array_keys($element['#options']);
  $all = array_shift($keys);

  $fieldset = array(
    '#title' => $element['#bef_title'],
    '#description' => $element['#bef_description'],
    '#attributes' => array(
      'class' => array(
        'bef-select-as-checkboxes-fieldset',
        'collapsible',
      ),
    ),
  );
  if (empty($element['#value'])) {
<<<<<<< HEAD
    // Using the FAPI #collapsible and #collapsed attribute doesn't work here
=======
    // Using the FAPI #collapsible and #collapsed attribute doesn't work here.
>>>>>>> SiteReformation
    // TODO: not sure why...
    $fieldset['#attributes']['class'][] = 'collapsed';
  }

  // We rendered the description as part of the fieldset element, don't render
<<<<<<< HEAD
  // it again along with the checkboxes
=======
  // it again along with the checkboxes.
>>>>>>> SiteReformation
  unset($element['#bef_description']);

  $children = '';
  if (!empty($element['#bef_operator'])) {
<<<<<<< HEAD
    // Put an exposed operator inside the fieldset
    $children = drupal_render($element['#bef_operator']);
  }

  // Render the radio buttons
=======
    // Put an exposed operator inside the fieldset.
    $children = drupal_render($element['#bef_operator']);
  }

  // Render the radio buttons.
>>>>>>> SiteReformation
  $children .= theme('select_as_radios', $element);

  $fieldset['#children'] = $children;
  return theme('fieldset', array('element' => $fieldset));
}

/**
<<<<<<< HEAD
 * Themes a select drop-down as a collection of radio buttons
 *
 * @see theme_select(), http://api.drupal.org/api/function/theme_select/7
 * @param array $vars - An array of arrays, the 'element' item holds the properties of the element.
 *                      Properties used: return_value, value, attributes, title, description
 * @return HTML string representing the form element.
=======
 * Themes a select drop-down as a collection of radio buttons.
 *
 * @see http://api.drupal.org/api/function/theme_select/7
 *
 * @param array $vars
 *   An array of arrays, the 'element' item holds the properties of the element.
 *
 * @return string
 *   HTML representing the form element.
>>>>>>> SiteReformation
 */
function theme_select_as_radios($vars) {
  $element = &$vars['element'];

  if (!empty($element['#bef_nested'])) {
    return theme('select_as_tree', $vars);
  }

  $output = '';
  foreach (element_children($element) as $key) {
    $element[$key]['#default_value'] = NULL;
    $element[$key]['#children'] = theme('radio', array('element' => $element[$key]));
    $output .= theme('form_element', array('element' => $element[$key]));
  }

  return $output;
}

/**
<<<<<<< HEAD
 * Themes a taxonomy-based exposed filter select element as a nested unordered list.  Note: this
 * routine depends on the '-' char prefixed on the term names by Views to determine depth.
 *
 * @param array $vars - An array of arrays, the 'element' item holds the properties of the element.
 * @return HTML
=======
 * Themes a taxonomy-based exposed filter as a nested unordered list.
 *
 * Note: this routine depends on the '-' char prefixed on the term names by
 * Views to determine depth.
 *
 * @param array $vars
 *   An array of arrays, the 'element' item holds the properties of the element.
 *
 * @return string
 *   Nested, unordered list of filter options
>>>>>>> SiteReformation
 */
function theme_select_as_tree($vars) {
  $element = $vars['element'];

<<<<<<< HEAD
  // The selected keys from #options
  $selected_options = empty($element['#value']) ? $element['#default_value'] : $element['#value'];

  /*
   *  Build a bunch of nested unordered lists to represent the hierarchy based on the '-' prefix
   *  added by Views or optgroup structure.
   */
  $output = '<ul class="bef-tree">';
  $curr_depth = 0;
  foreach ($element['#options'] as $option_value => $option_label) {

    // Check for Taxonomy-based filters
=======
  // The selected keys from #options.
  $selected_options = empty($element['#value']) ? $element['#default_value'] : $element['#value'];

  // Build a bunch of nested unordered lists to represent the hierarchy based
  // on the '-' prefix added by Views or optgroup structure.
  $output = '<ul class="bef-tree">';
  $curr_depth = -1;
  foreach ($element['#options'] as $option_value => $option_label) {

    // Check for Taxonomy-based filters.
>>>>>>> SiteReformation
    if (is_object($option_label)) {
      $slice = array_slice($option_label->option, 0, 1, TRUE);
      list($option_value, $option_label) = each($slice);
    }

<<<<<<< HEAD
    // Check for optgroups -- which is basically a two-level deep tree
=======
    // Check for optgroups -- which is basically a two-level deep tree.
>>>>>>> SiteReformation
    if (is_array($option_label)) {
      // TODO:
    }
    else {
<<<<<<< HEAD
      // Build hierarchy based on prefixed '-' on the element label
      if (t('- Any -') == $option_label) {
        $depth = 0;
=======
      // Build hierarchy based on prefixed '-' on the element label.
      if (t('- Any -') == $option_label) {
        $depth = -1;
>>>>>>> SiteReformation
      }
      else {
        preg_match('/^(-*).*$/', $option_label, $matches);
        $depth = strlen($matches[1]);
        $option_label = ltrim($option_label, '-');
      }

<<<<<<< HEAD
      // Build either checkboxes or radio buttons, depending on Views' settings
=======
      // Build either checkboxes or radio buttons, depending on Views' settings.
>>>>>>> SiteReformation
      $html = '';
      if (!empty($element['#multiple'])) {
        $html = bef_checkbox(
          $element,
          $option_value,
          $option_label,
          (array_search($option_value, $selected_options) !== FALSE)
        );
      }
      else {
        $element[$option_value]['#title'] = $option_label;
        $element[$option_value]['#children'] = theme('radio', array('element' => $element[$option_value]));
        $html .= theme('form_element', array('element' => $element[$option_value]));
      }

      if ($depth > $curr_depth) {
<<<<<<< HEAD
        // We've moved down a level: create a new nested <ul>
        // TODO: Is there is a way to jump more than one level deeper at a time?  I don't think so...
=======
        // We've moved down a level: create a new nested <ul>.
        // TODO: Is there is a way to jump more than one level deeper at a time?
        // I don't think so...
>>>>>>> SiteReformation
        $output .= "<ul class='bef-tree-child bef-tree-depth-$depth'><li>$html";
        $curr_depth = $depth;
      }
      elseif ($depth < $curr_depth) {
<<<<<<< HEAD
        // We've moved up a level: finish previous <ul> and <li> tags, once for each level, since we
        // can jump multiple levels up at a time.
=======
        // We've moved up a level: finish previous <ul> and <li> tags, once for
        // each level, since we can jump multiple levels up at a time.
>>>>>>> SiteReformation
        while ($depth < $curr_depth) {
          $output .= '</li></ul>';
          $curr_depth--;
        }
        $output .= "</li><li>$html";
      }
      else {
<<<<<<< HEAD
        // Remain at same level as previous entry. No </li> needed if we're at the top level
        if (0 == $curr_depth) {
          $output .= "<li>$html";
        }
        else {
=======
        if (-1 == $curr_depth) {
          // No </li> needed -- this is the first element.
          $output .= "<li>$html";
          $curr_depth = 0;
        }
        else {
          // Remain at same level as previous entry.
>>>>>>> SiteReformation
          $output .= "</li><li>$html";
        }
      }
    }
<<<<<<< HEAD
  }                             // foreach ($element['#options'] as $option_value => $option_label)

  if (!$curr_depth) {
    // Close last <li> tag
    $output .= '</li>';
  }
  else {
    // Finish closing <ul> and <li> tags
=======
  } // foreach ($element['#options'] as $option_value => $option_label)

  if (!$curr_depth) {
    // Close last <li> tag.
    $output .= '</li>';
  }
  else {
    // Finish closing <ul> and <li> tags.
>>>>>>> SiteReformation
    while ($curr_depth) {
      $curr_depth--;
      $output .= '</li></ul></li>';
    }
  }

<<<<<<< HEAD
  // Close the opening <ul class="bef-tree"> tag
  $output .= '</ul>';

  // Add exposed filter description
  $description = '';
  if (!empty($element['#bef_description'])) {
    $description = '<div class="description">'. $element['#bef_description'] .'</div>';
  }

  // Add the select all/none option, if needed
=======
  // Close the opening <ul class="bef-tree"> tag.
  $output .= '</ul>';

  // Add exposed filter description.
  $description = '';
  if (!empty($element['#bef_description'])) {
    $description = '<div class="description">' . $element['#bef_description'] . '</div>';
  }

  // Add the select all/none option, if needed.
>>>>>>> SiteReformation
  if (!empty($element['#bef_select_all_none'])) {
    if (empty($element['#attributes']['class'])) {
      $element['#attributes']['class'] = array();
    }
    $element['#attributes']['class'][] = 'bef-select-all-none';
  }
<<<<<<< HEAD
=======
  // Add the select all/none nested option, if needed.
  if (!empty($element['#bef_select_all_none_nested'])) {
    if (empty($element['#attributes']['class'])) {
      $element['#attributes']['class'] = array();
    }
    $element['#attributes']['class'][] = 'bef-select-all-none-nested';
  }

  // Name and multiple attributes are not valid for <div>'s.
  if (isset($element['#attributes']['name'])) {
    unset($element['#attributes']['name']);
  }
  if (isset($element['#attributes']['multiple'])) {
    unset($element['#attributes']['multiple']);
  }
>>>>>>> SiteReformation

  return '<div' . drupal_attributes($element['#attributes']) . ">$description$output</div>";
}

/**
<<<<<<< HEAD
 * Themes a select drop-down as a collection of links
 *
 * @see theme_select(), http://api.drupal.org/api/function/theme_select/6
 * @param array $vars - An array of arrays, the 'element' item holds the properties of the element.
 *                      Properties used: title, value, options, description, name
 * @return HTML string representing the form element.
=======
 * Themes a select drop-down as a collection of links.
 *
 * @see http://api.drupal.org/api/function/theme_select/7
 *
 * @param array $vars
 *   An array of arrays, the 'element' item holds the properties of the element.
 *
 * @return string
 *   HTML representing the form element.
>>>>>>> SiteReformation
 */
function theme_select_as_links($vars) {
  $element = $vars['element'];

  $output = '';
  $name = $element['#name'];

<<<<<<< HEAD
  // Collect selected values so we can properly style the links later
=======
  // Collect selected values so we can properly style the links later.
>>>>>>> SiteReformation
  $selected_options = array();
  if (empty($element['#value'])) {
    if (!empty($element['#default_values'])) {
      $selected_options[] = $element['#default_values'];
    }
  }
  else {
    $selected_options[] = $element['#value'];
  }

  // Add to the selected options specified by Views whatever options are in the
<<<<<<< HEAD
  // URL query string, but only for this filter
=======
  // URL query string, but only for this filter.
>>>>>>> SiteReformation
  $urllist = parse_url(request_uri());
  if (isset($urllist['query'])) {
    $query = array();
    parse_str(urldecode($urllist['query']), $query);
    foreach ($query as $key => $value) {
      if ($key != $name) {
        continue;
      }
      if (is_array($value)) {
<<<<<<< HEAD
        // This filter allows multiple selections, so put each one on the selected_options array
=======
        // This filter allows multiple selections, so put each one on the
        // selected_options array.
>>>>>>> SiteReformation
        foreach ($value as $option) {
          $selected_options[] = $option;
        }
      }
      else {
        $selected_options[] = $value;
      }
    }
  }

<<<<<<< HEAD
  // Clean incoming values to prevent XSS attacks
  if (is_array($element['#value'])) {
    foreach($element['#value'] as $index => $item) {
      unset($element['#value'][$index]);
      $element['#value'][filter_xss($index)] = filter_xss($item);
    }
  }
  else if (is_string($element['#value'])) {
    $element['#value'] = filter_xss($element['#value']);
  }

  // Go through each filter option and build the appropriate link or plain text
  foreach ($element['#options'] as $option => $elem) {
    // Check for Taxonomy-based filters
=======
  // Clean incoming values to prevent XSS attacks.
  if (is_array($element['#value'])) {
    foreach ($element['#value'] as $index => $item) {
      unset($element['#value'][$index]);
      $element['#value'][check_plain($index)] = check_plain($item);
    }
  }
  elseif (is_string($element['#value'])) {
    $element['#value'] = check_plain($element['#value']);
  }

  // Go through each filter option and build the appropriate link or plain text.
  foreach ($element['#options'] as $option => $elem) {
    if (!empty($element['#hidden_options'][$option])) {
      continue;
    }
    // Check for Taxonomy-based filters.
>>>>>>> SiteReformation
    if (is_object($elem)) {
      $slice = array_slice($elem->option, 0, 1, TRUE);
      list($option, $elem) = each($slice);
    }

<<<<<<< HEAD
    /*
     * Check for optgroups.  Put subelements in the $element_set array and add a group heading.
     * Otherwise, just add the element to the set
     */
=======
    // Check for optgroups.  Put subelements in the $element_set array and add
    // a group heading. Otherwise, just add the element to the set.
>>>>>>> SiteReformation
    $element_set = array();
    if (is_array($elem)) {
      $element_set = $elem;
    }
    else {
      $element_set[$option] = $elem;
    }

    $links = array();
    $multiple = !empty($element['#multiple']);

<<<<<<< HEAD
    foreach ($element_set as $key => $value) {
      // Custom ID for each link based on the <select>'s original ID
=======
    // If we're in an exposed block, we'll get passed a path to use for the
    // Views results page.
    $path = '';
    if (!empty($element['#bef_path'])) {
      $path = $element['#bef_path'];
    }

    foreach ($element_set as $key => $value) {
      $element_output = '';
      // Custom ID for each link based on the <select>'s original ID.
>>>>>>> SiteReformation
      $id = drupal_html_id($element['#id'] . '-' . $key);
      $elem = array(
        '#id' => $id,
        '#markup' => '',
        '#type' => 'bef-link',
        '#name' => $id,
      );
      if (array_search($key, $selected_options) === FALSE) {
<<<<<<< HEAD
        $elem['#children'] = l($value, bef_replace_query_string_arg($name, $key, $multiple));
        $output .= theme('form_element', array('element' => $elem));
      } else {
        $elem['#children'] = l($value, bef_replace_query_string_arg($name, $key, $multiple, true));
        _form_set_class($elem, array('bef-select-as-links-selected'));
        $output .= str_replace('form-item', 'form-item selected', theme('form_element', array('element' => $elem)));
      }
=======
        $elem['#children'] = l($value, bef_replace_query_string_arg($name, $key, $multiple, FALSE, $path));
        //$output .= theme('form_element', array('element' => $elem));
        $element_output = theme('form_element', array('element' => $elem));

          if ($element['#name'] == 'sort_bef_combine' && !empty($element['#settings']['toggle_links'])) {
            $sort_pair = explode(' ', $key);
            if (count($sort_pair) == 2) {
              // Highlight the link if it is the selected sort_by (can be either
              // asc or desc, it doesn't matter).
             if (strpos($selected_options[0], $sort_pair[0]) === 0) {
                $element_output = str_replace('form-item', 'form-item selected', $element_output);
              }
            }
          }
        } else {
        $elem['#children'] = l($value, bef_replace_query_string_arg($name, $key, $multiple, TRUE, $path));
        _form_set_class($elem, array('bef-select-as-links-selected'));
        //$output .= str_replace('form-item', 'form-item selected', theme('form_element', array('element' => $elem)));
        $element_output = str_replace('form-item', 'form-item selected', theme('form_element', array('element' => $elem)));
      }
      $output .= $element_output;

>>>>>>> SiteReformation
    }
  }

  $properties = array(
    '#description' => isset($element['#bef_description']) ? $element['#bef_description'] : '',
    '#children' => $output,
  );

  $output = '<div class="bef-select-as-links">';
  $output .= theme('form_element', array('element' => $properties));
  if (!empty($element['#value'])) {
    if (is_array($element['#value'])) {
      foreach ($element['#value'] as $value) {
        $output .= '<input type="hidden" name="' . $name . '[]" value="' . $value . '" />';
      }
    }
    else {
      $output .= '<input type="hidden" name="' . $name . '" value="' . $element['#value'] . '" />';
    }
  }
  $output .= '</div>';

  return $output;
}

/**
<<<<<<< HEAD
 * Themes some exposed form elements in a collapsible fieldset
 *
 * @param array $vars - An array of arrays, the 'element' item holds the
 *        properties of the element.
 * @return HTML
=======
 * Themes some exposed form elements in a collapsible fieldset.
 *
 * @param array $vars
 *   An array of arrays, the 'element' item holds the properties of the element.
 *
 * @return string
 *   HTML to render the form element.
>>>>>>> SiteReformation
 */
function theme_secondary_exposed_elements($vars) {
  $element = $vars['element'];

  $output = '<div class="bef-secondary-options">';
<<<<<<< HEAD
  foreach(element_children($element) as $id) {
=======
  foreach (element_children($element) as $id) {
>>>>>>> SiteReformation
    $output .= drupal_render($element[$id]);
  }
  $output .= '</div>';

  return $output;
}

<<<<<<< HEAD

/*
 * Helper functions
 */

/**
 * Build a BEF checkbox -- very similar to theme_checkbox
 * (http://api.drupal.org/api/function/theme_checkbox/6)
 *
 * @param $element - array: original <select> element generated by Views
 * @param $value - string: value of this checkbox option
 * @param $label - string: label for this checkbox option
 * @param $selected - bool: checked or not
 * @return string: checkbox HTML
 */
function bef_checkbox($element, $value, $label, $selected) {
  $value = check_plain($value);
  $label = check_plain($label);
  $id = drupal_html_id($element['#id'] . '-' . $value);
  // Custom ID for each checkbox based on the <select>'s original ID
=======
/*
 *
 * Helper functions
 *
 */

/**
 * Build a BEF checkbox.
 *
 * @see http://api.drupal.org/api/function/theme_checkbox/7
 *
 * @param array $element
 *   Original <select> element generated by Views.
 * @param string $value
 *   Return value of this checkbox option.
 * @param string $label
 *   Label of this checkbox option.
 * @param bool $selected
 *   Checked or not.
 *
 * @return [type]
 *   HTML to render a checkbox.
 */
function bef_checkbox($element, $value, $label, $selected) {
  $value = check_plain($value);
  $label = filter_xss_admin($label);
  $id = drupal_html_id($element['#id'] . '-' . $value);
  // Custom ID for each checkbox based on the <select>'s original ID.
>>>>>>> SiteReformation
  $properties = array(
    '#required' => FALSE,
    '#id' => $id,
    '#type' => 'bef-checkbox',
    '#name' => $id,
  );

<<<<<<< HEAD
  // Prevent the select-all-none class from cascading to all checkboxes
=======
  // Prevent the select-all-none class from cascading to all checkboxes.
>>>>>>> SiteReformation
  if (!empty($element['#attributes']['class'])
      && FALSE !== ($key = array_search('bef-select-all-none', $element['#attributes']['class']))) {
    unset($element['#attributes']['class'][$key]);
  }

  // Unset the name attribute as we are setting it manually.
  unset($element['#attributes']['name']);

<<<<<<< HEAD
  $checkbox = '<input type="checkbox" '
   . 'name="' . $element['#name'] . '[]" '    // brackets are key -- just like select
=======
  // Unset the multiple attribute as it doesn't apply for checkboxes.
  unset ($element['#attributes']['multiple']);

  $checkbox = '<input type="checkbox" '
    // Brackets are key -- just like select.
    . 'name="' . $element['#name'] . '[]" '
>>>>>>> SiteReformation
    . 'id="' . $id . '" '
    . 'value="' . $value . '" '
    . ($selected ? 'checked="checked" ' : '')
    . drupal_attributes($element['#attributes']) . ' />';
  $properties['#children'] = "$checkbox <label class='option' for='$id'>$label</label>";
  $output = theme('form_element', array('element' => $properties));
  return $output;
}

/**
<<<<<<< HEAD
 * Replaces/adds a given query string argument to the current URL
 *
 * @param string $key query string key (argument)
 * @param string $value query string value
 * @param bool $multiple TRUE if this key/value pair allows multiple values
 * @param bool $remove TRUE if this key/value should be a link to remove/unset the filter
 */
function bef_replace_query_string_arg($key, $value, $multiple = FALSE, $remove = FALSE) {
  $path = arg();

  // Prevents us from having to check for each index from parse_url that we may use
=======
 * Replaces/adds a given query string argument to the current URL.
 *
 * @param string $key
 *   Query string key (argument).
 * @param string $value
 *   Query string value.
 * @param bool $multiple
 *   (optional) TRUE if this key/value pair allows multiple values.
 * @param bool $remove
 *   (optional) TRUE if this key/value should be a link to remove/unset the
 *   filter.
 * @param string $path
 *   (optional) Use this specify the View results page when the exposed form
 *   is displayed as a block and may be a different URL from the results.
 *   Defaults to the current path if unspecified.
 *
 * @return string
 *   URL.
 */
function bef_replace_query_string_arg($key, $value, $multiple = FALSE, $remove = FALSE, $path = '') {
  if (!$path) {
    $path = implode('/', arg());
  }

  // Prevents us from having to check for each index from parse_url that we may
  // use.
>>>>>>> SiteReformation
  $urllist = array('path' => '', 'fragment' => '', 'query' => '');
  $urllist = array_merge($urllist, parse_url(request_uri()));
  $fragment = urldecode($urllist['fragment']);
  $query = array();
  parse_str(urldecode($urllist['query']), $query);
  if (isset($query[$key]) && is_array($query[$key])) {
<<<<<<< HEAD
    // multiple values allowed for this existing key
    if ($remove && ($key_remove = array_search($value, $query[$key])) !== false)
      unset($query[$key][$key_remove]);
    else
      $query[$key][] = $value;
  }
  else {
    // Create a new key
=======
    // Multiple values allowed for this existing key.
    if ($remove && ($key_remove = array_search($value, $query[$key])) !== FALSE) {
      unset($query[$key][$key_remove]);
    }
    else {
      $query[$key][] = $value;
    }
  }
  else {
    // Create a new key.
>>>>>>> SiteReformation
    if ($multiple && !$remove) {
      $query[$key] = array($value);
    }
    elseif (!$remove) {
      $query[$key] = $value;
    }
  }
<<<<<<< HEAD
  return url(implode('/', $path), array(
=======
  // Unset page arg so we don't land on an empty page off the end of the newly filtered listing
  unset($query['page']);
  return url($path, array(
>>>>>>> SiteReformation
    'query' => $query,
    'fragment' => $fragment,
    'absolute' => TRUE,
  ));
}
